\chap[follow_the_gap] Migration

Having introduced ROS 1 and 2 and having described the components of the CTU's F1/10 platform, we can move on to the actual migration from ROS 1 to ROS 2.


\sec Note about Different ROS 2 Releases

Throughout the time we worked with the CTU's F1/10 platform, multiple ROS 2 versions were released.

\begitems
* May 2020: 6th release ROS 2 Foxy Fitzroy (Ubuntu 20) (EOL: May 2023\footnote{Foxy was the first ROS 2 release with 3-year support. That signified the stability of this release. And Humble even came with a 5-year support plan.})
* May 2021: 7th release ROS 2 Galactic Geochelone (Ubuntu 20) (EOL: November 2022)
* May 2022: 8th release ROS 2 Humble Hawksbill (Ubuntu 22) (EOL: May 2027)
* rolling release: ROS 2 Rolling Ridley
\enditems

First, we targeted just Foxy and Galactic. Then, in order to get access to the latest features and performance improvements, we made the necessary changes to support the latest release, Humble, and the Rolling release as well. In the end, the migrated stack should be runnable in (at least) all these ROS 2 versions.


\sec Scope of the Migration

Currently, the CTU's F1/10 platform is based on ROS 1 Kinetic Kame, which was released in May 2016 and deprecated in May 2021. That, among other things, means it runs on Ubuntu 16 and all ROS Python nodes are written in Python 2. The jump between ROS 1 Kinetic Kame and the current ROS 2 release might be significant. We might face a lot of silly issues with dependencies.

Because migrating all the code of the CTU's F1/10 platform at once would not be wise (footnote: technical debt), we want to start with a self-contained part of it that we will actually try to migrate. Such part should meet at least the following criteria:

\begitems
* It is possible to easily demonstrate its working in a simulator and on a physical car.
* It contains a minimal number of dependencies.
* It represents a typical autonomous driving application. That means reading data from sensor(s) (LiDAR), analyzing the data (perception), planning a trajectory (decision and control), and controlling the vehicle.
\enditems

All these criteria are met by the Follow the Gap application, which is a part of the CTU F1/10 platform. It implements a reactive algorithm called Follow the Gap that was first introduced in ~\cite[paper_follow_the_gap]. It is a well-known part of the CTU's stack that was responsible for several wins of the CTU team in the F1Tenth Autonomous Competition in the past.

Additionally, the migrated stack should be as compatible as possible (at least in the beginning) so that we can port more algorithms without rewriting their logic. This concerns especially the Drive-API.

Another thing to keep in mind is that the migration comprises not only porting the actual code to ROS 2, but also setting up the NVIDIA Jetson TX2 so that it can run ROS 2 (which is done in Chapter~\ref[jetson]).


\sec Follow the Gap Overview

We started by analyzing the operation of the Follow the Gap in its original ROS 1 environment. Then we also examined its code. We identified the packages that needed to be migrated to ROS 2.

There are three main parts that power the application:

\begitems
* "perception/recognition/obstacle_substitution" – A package with one node that converts data from LiDAR to obstacles.
* "decision_and_control/follow_the_gap_v0" – A package that consists of two nodes. The first is the actual algorithm that looks for the biggest gap. Its output is the heading angle leading to the biggest gap. This heading angle is converted by the second node to the control commands, which are then sent to the Drive-API.
* Vehicle Platform (Drive-API, VESC, Teensy)
\enditems

Apart from the nodes, there are messages' definitions, launch files, and various configuration files that need to be migrated too.


\sec Process of the Migration

After we got familiar with the structure of the application in the ROS 1 environment, we actually proceeded with the migration itself. It was not an easy task as there were lots of tricky details and issues that needed to be solved. It required a lot of searching in the official documentation as well as examining the ROS 2 source code and examples as not all concepts were equally well documented.

In the following subsections, we describe some of the interesting challenges we faced during the process.

\secc Parameters

Unlike ROS 1, ROS 2 has no global Parameter Server. Instead, in ROS 2, parameters are managed per node. Each node implements a parameter service that allows getting and setting the parameters during runtime. Initial values of parameters can be supplied at node startup time via command line arguments (parameters file). One of the most useful advantages this design brings is that all parameters can be easily changed during runtime, and nodes can implement custom behavior for handling the changes. In ROS 1, one must use solutions like "dynamic_reconfigure"\urlnote{https://wiki.ros.org/dynamic_reconfigure} to get similar results.

One could argue that in some situations, it might be useful to have a “global parameter storage”. Although that might be true sometimes (footnote: pass one param to all nodes), usually, the relationship between a parameter and a node where it should be defined is quite apparent.

For the CTU's F1/10 codebase, we were able to move all global parameters to logically-related nodes. At the same time, we got the ability to dynamically change the parameters, which proved to be useful, especially for the "follow_the_gap_v0_ride" node.


\secc Teensy

As already mentioned in (TODO: ref Teensy), the communication between the Teensy MCU and the Jetson is implemented using rosserial (TODO: https://github.com/ros-drivers/rosserial). There is no direct port of rosserial in ROS 2 \urlnote{https://github.com/ros2/ros2/issues/365} \urlnote{https://newscrewdriver.com/2020/08/05/notes-on-ros2-and-rosserial}. The official replacement in ROS 2 is micro-ROS (\urlnote{https://micro.ros.org/}, \urlnote{https://micro.ros.org/docs/concepts/middleware/rosserial/}) which is built around Micro XRCE-DDS middleware. Given the scope and goal of the project (to bring as much of ROS 2 to MCUs as possible), the overall complexity and hardware requirements are rather high.

In order to avoid unnecessary complexity and overhead of micro-ROS, we decided to implement our own simple communication protocol between the Jetson and the Teensy. We implemented a C library (usable also from C++) for serializing and deserializing messages. This library can be used in the Teensy (bare-metal) as well as in the Jetson (Linux).

Next, we had to rewrite the firmware for the Teensy incorporating the new communication protocol. While doing that, we also tried to document some parts of the original code. However, there is still a big room for improvement.

Finally, we implemented a ROS 2 node called "teensy_drive" that connects to the Teensy via USB (CDC-ACM) and receives and send appropriate messages between Teensy and the ROS 2 network.


\secc Stage simulator

In order to reuse the simulation from ROS 1~\ref[todo], we needed to have working bindings between ROS 2 and the Stage simulator.

We found "stage_ros2"\urlnote{https://github.com/ymd-stella/stage_ros2} package which is doing exactly that. However, it required a few changes in order to be usable in the latest ROS 2. We created a fork "pokusew/stage_ros2"\urlnote{https://github.com/pokusew/stage_ros2} and implemented those changes. The author of the original repository even starred (footnote) our repository. Once there is more time, we will attempt to get our changes merged upstream.

Finally, we had to build both the Stage simulator (because there is no package available in recent Ubuntu releases) and our modified stage_ros2 from the source. In the end, we integrated everything to the main workspace (TODO: footnote).


\secc NVIDIA Jetson TX2 Setup

One of the most significant challenges was running the migrated stack on the Jetson. It included many different steps such as:

\begitems
* Flashing an up-to-date OS image – NVIDIA's modified Linux – Linux for Tegra (L4T) together with all the drivers and other software components that make up the JetPack SDK.
* Creating a bootable SD card and making the Jetson boot from it instead of its internal eMMC. This way, we easily switch between different OS images, and we can also get bigger storage (the internal eMMC has a capacity of 32 GB).
* Configuring the system (udev rules, Wi-Fi, SSH, etc.) and installing any necessary software.
\enditems

We collected a lot of documentation, notes, commands, links, and configuration regarding Jetson in our ros-setup repository (footnote: https://github.com/pokusew/ros-setup/tree/main/nvidia-jetson-tx2).

Nevertheless, the main problem was Jetson's outdated software and its specifics. At the time of writing, the latest available NVIDIA JetPack is 4.6.1, which is based on Ubuntu 18. At the same time, the latest available Ubuntu LTS release is Ubuntu 22.

Officially, no ROS 2 version we target supports Ubuntu 18 (TODO: ref ROS 2 versions). However, one can attempt to build ROS 2 from sources even on older Ubuntus, but one must be prepared to face some problems with outdated system dependencies. We tried to do that for Foxy and Galactic and we were (after some struggles) successful.

Running ROS 2 natively on the Jeston is surely nice. Nevertheless, one has to build all application dependencies from their source code, as no prebuilt apt ROS packages are provided by ROS.

Another possibility is to use Docker containers. Containers (OCI containers) provide means for isolating applications running in the same OS. They are implemented using native Linux features, most notably namespaces and control groups. Containers are very efficient; they share the Linux kernel, thus having basically zero overhead. One could see containers as properly isolated OS processes.

Most importantly for us, we can create containers based on Ubuntu 20 or Ubuntu 22 filesystems and use them to run our ROS 2 stack even on the Jetson with Ubuntu 18. Docker containers can be configured to use the host network adapter, reducing any network overhead and simplifying the ROS 2 setup (it is exactly the same as if the application was running outside the container).

To sum up, we tried both options (build from source and Docker containers). While the Docker containers require more setup, they effectively solve the problem with outdated system dependencies in the systems like Ubuntu.


\sec Result

Once we successfully migrated all the needed parts, we were able to demonstrate the working of the migrated application:
\begitems
* on the real car
* in the Stage simulator on Ubuntu and macOS (footnote: we also made it run on macOS)
\enditems

The code can be found in "f1tenth_rewrite"\urlnote{https://github.com/pokusew/f1tenth-rewrite} repository.

\midinsert
\clabel[img_follow_the_gap_ros2_stage_ubuntu]{Follow the Gap in the Stage simulator on~Ubuntu}
\picw=14cm \cinspic ../images/follow_the_gap_ros2_stage_ubuntu.png
\caption/f Running the Follow the Gap application in the Stage simulator in ROS~2 on~Ubuntu~20.04 (as a~VM on~macOS)
\endinsert

\midinsert
\clabel[img_follow_the_gap_ros2_stage_macos]{Follow the Gap in the Stage simulator on~macOS}
\picw=14cm \cinspic ../images/follow_the_gap_ros2_stage_macOS.png
\caption/f Running the Follow the Gap application in the Stage simulator in ROS~2 \hbox{on~macOS~10.14.6}
\endinsert
